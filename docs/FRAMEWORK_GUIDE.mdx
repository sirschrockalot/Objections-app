# Framework Guide: Building Apps with Next.js, Security, Caching, and Logging

This guide documents the complete framework stack used in this application, including coding patterns, security implementations, caching strategies, and logging capabilities. Use this as a reference when building new applications with similar requirements.

## Table of Contents

1. [Framework Stack](#framework-stack)
2. [Security Implementation](#security-implementation)
3. [Caching Strategy](#caching-strategy)
4. [Logging System](#logging-system)
5. [API Route Handler Pattern](#api-route-handler-pattern)
6. [Database Setup](#database-setup)
7. [Code Structure](#code-structure)
8. [Environment Variables](#environment-variables)
9. [Best Practices](#best-practices)

---

## Framework Stack

### Core Technologies

- **Next.js 16** - React framework with App Router
- **React 19** - UI library
- **TypeScript 5** - Type safety
- **MongoDB + Mongoose** - Database and ODM
- **Node.js** - Runtime environment

### Styling & UI

- **Tailwind CSS v4** - Utility-first CSS framework
- **Radix UI** - Headless component primitives
- **shadcn/ui** - Component library built on Radix
- **Framer Motion** - Animation library
- **Lucide React** - Icon library
- **class-variance-authority (cva)** - Component variants
- **tailwind-merge** - Merge Tailwind classes
- **clsx** - Conditional class names

### Key Dependencies

```json
{
  "dependencies": {
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "typescript": "^5",
    "mongoose": "^9.0.0",
    "jsonwebtoken": "^9.0.3",
    "bcryptjs": "^3.0.3",
    "node-cache": "^5.1.2",
    "tailwindcss": "^4",
    "@radix-ui/react-slot": "^1.2.4",
    "framer-motion": "^12.23.25",
    "lucide-react": "^0.555.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "tailwind-merge": "^3.4.0"
  }
}
```

---

## Security Implementation

### JWT Authentication

**File: `lib/jwt.ts`**

JWT-based stateless authentication with short-lived access tokens and long-lived refresh tokens.

#### Key Features:
- **Access Tokens**: 15 minutes expiration (configurable via `JWT_EXPIRES_IN`)
- **Refresh Tokens**: 7 days expiration (configurable via `JWT_REFRESH_EXPIRES_IN`)
- **Token Rotation**: New refresh token on each refresh (prevents token reuse)
- **Secure Secret**: Minimum 32 characters (warns if using default)

#### Implementation:

```typescript
// lib/jwt.ts
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'change-this-in-production-minimum-32-characters';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '15m';
const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';

export interface JWTPayload {
  userId: string;
  isAdmin: boolean;
  email: string;
  iat?: number;
  exp?: number;
}

// Sign access token
export function signToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

// Sign refresh token
export function signRefreshToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });
}

// Verify token
export function verifyToken(token: string): JWTPayload | null {
  try {
    return jwt.verify(token, JWT_SECRET) as JWTPayload;
  } catch {
    return null;
  }
}

// Extract from Authorization header
export function getTokenFromRequest(request: Request): string | null {
  const authHeader = request.headers.get('authorization');
  if (!authHeader?.startsWith('Bearer ')) return null;
  return authHeader.substring(7);
}
```

### Authentication Middleware

**File: `lib/authMiddleware.ts`**

Middleware for protecting API routes with authentication and admin checks.

#### Implementation:

```typescript
// lib/authMiddleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken, getTokenFromRequest } from '@/lib/jwt';
import connectDB from '@/lib/mongodb';
import User from '@/lib/models/User';

export interface AuthResult {
  authenticated: boolean;
  userId?: string;
  isAdmin?: boolean;
  email?: string;
  error?: string;
  statusCode?: number;
}

// Require authentication
export async function requireAuth(
  request: NextRequest,
  options: { checkActive?: boolean } = {}
): Promise<AuthResult> {
  const token = getTokenFromRequest(request);
  if (!token) {
    return { authenticated: false, error: 'Authentication required', statusCode: 401 };
  }

  const payload = verifyToken(token);
  if (!payload) {
    return { authenticated: false, error: 'Invalid or expired token', statusCode: 401 };
  }

  // Verify user is active in database
  if (options.checkActive !== false) {
    await connectDB();
    const user = await User.findById(payload.userId).lean();
    if (!user || !user.isActive) {
      return { authenticated: false, error: 'User account is inactive', statusCode: 401 };
    }
    return {
      authenticated: true,
      userId: payload.userId,
      isAdmin: user.isAdmin || false,
      email: user.username,
    };
  }

  return {
    authenticated: true,
    userId: payload.userId,
    isAdmin: payload.isAdmin,
    email: payload.email,
  };
}

// Require admin privileges
export async function requireAdmin(request: NextRequest): Promise<AuthResult> {
  const auth = await requireAuth(request);
  if (!auth.authenticated) return auth;
  
  if (!auth.isAdmin) {
    return { authenticated: false, error: 'Admin access required', statusCode: 403 };
  }
  
  return auth;
}

// Create standardized auth error response
export function createAuthErrorResponse(auth: AuthResult): NextResponse {
  return NextResponse.json(
    { error: auth.error || 'Authentication failed' },
    { status: auth.statusCode || 401 }
  );
}
```

### Password Security

- **Minimum Length**: 12 characters
- **Complexity Requirements**: Uppercase, lowercase, number, special character
- **Hashing**: bcrypt with 12 rounds (configurable)
- **Validation**: Centralized utility function

### Security Headers

**File: `next.config.ts`**

Security headers applied to all routes:

```typescript
async headers() {
  return [
    {
      source: '/:path*',
      headers: [
        { key: 'Strict-Transport-Security', value: 'max-age=31536000; includeSubDomains; preload' },
        { key: 'X-Frame-Options', value: 'DENY' },
        { key: 'X-Content-Type-Options', value: 'nosniff' },
        { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
        { key: 'X-XSS-Protection', value: '1; mode=block' },
        { key: 'Permissions-Policy', value: 'camera=(), microphone=(), geolocation=()' },
        { key: 'Content-Security-Policy', value: "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; ..." },
      ],
    },
  ];
}
```

### Rate Limiting

**File: `lib/rateLimiter.ts`**

Server-side rate limiting with hybrid in-memory (node-cache) + MongoDB persistence.

#### Features:
- **In-memory cache** for fast access (primary)
- **MongoDB persistence** for distributed systems (fallback)
- **TTL-based expiration** (automatic cleanup)
- **Configurable limits** per endpoint type

#### Implementation:

```typescript
// lib/rateLimiter.ts
import NodeCache from 'node-cache';
import { NextRequest, NextResponse } from 'next/server';
import connectDB from '@/lib/mongodb';
import mongoose, { Schema } from 'mongoose';

// In-memory cache (primary)
const memoryCache = new NodeCache({
  stdTTL: 3600, // 1 hour default
  checkperiod: 300, // Check every 5 minutes
});

// Rate limit configuration
export interface RateLimitConfig {
  windowMs: number; // Time window in milliseconds
  maxRequests: number; // Max requests per window
  identifier?: (req: NextRequest) => string; // Custom identifier function
}

export const RATE_LIMITS = {
  auth: { windowMs: 15 * 60 * 1000, maxRequests: 5 }, // 5 per 15 min
  api: { windowMs: 60 * 1000, maxRequests: 60 }, // 60 per minute
  read: { windowMs: 60 * 1000, maxRequests: 100 }, // 100 per minute
};

// Create rate limit middleware
export function createRateLimitMiddleware(config: RateLimitConfig) {
  return async (request: NextRequest) => {
    const identifier = config.identifier 
      ? config.identifier(request)
      : request.headers.get('x-forwarded-for') || 
        request.headers.get('x-real-ip') || 
        'unknown';
    
    const key = `ratelimit:${identifier}`;
    
    // Check in-memory cache first
    let record = memoryCache.get<RateLimitRecord>(key);
    
    if (!record || Date.now() > record.resetTime) {
      // Check MongoDB (for distributed systems)
      await connectDB();
      const dbRecord = await RateLimitModel.findOne({ identifier: key });
      
      if (dbRecord && new Date(dbRecord.resetTime) > new Date()) {
        record = {
          count: dbRecord.count,
          resetTime: new Date(dbRecord.resetTime).getTime(),
        };
      } else {
        // Create new record
        record = {
          count: 0,
          resetTime: Date.now() + config.windowMs,
        };
      }
    }
    
    // Check limit
    if (record.count >= config.maxRequests) {
      return {
        allowed: false,
        remaining: 0,
        response: NextResponse.json(
          { error: 'Too many requests', retryAfter: Math.ceil((record.resetTime - Date.now()) / 1000) },
          { status: 429 }
        ),
      };
    }
    
    // Increment count
    record.count++;
    memoryCache.set(key, record, Math.ceil((record.resetTime - Date.now()) / 1000));
    
    // Persist to MongoDB
    await RateLimitModel.findOneAndUpdate(
      { identifier: key },
      {
        identifier: key,
        count: record.count,
        resetTime: new Date(record.resetTime),
      },
      { upsert: true }
    );
    
    return {
      allowed: true,
      remaining: config.maxRequests - record.count,
    };
  };
}
```

---

## Caching Strategy

### Hybrid Caching Architecture

Two-tier caching system: **In-memory (node-cache)** for speed + **MongoDB** for persistence.

### AI Response Caching

**File: `lib/cache/aiCache.ts`**

Caches AI API responses to reduce costs and improve performance.

#### Features:
- **24-hour TTL** for AI responses
- **Task-based categorization** (market-analysis, feedback, categorization)
- **Automatic expiration** via MongoDB TTL index
- **Cache key hashing** for consistent lookups

#### Implementation:

```typescript
// lib/cache/aiCache.ts
import NodeCache from 'node-cache';
import connectDB from '@/lib/mongodb';
import mongoose, { Schema } from 'mongoose';
import crypto from 'crypto';

// In-memory cache (primary)
const memoryCache = new NodeCache({
  stdTTL: 86400, // 24 hours
  checkperiod: 3600, // Check every hour
});

// MongoDB schema with TTL index
const AICacheSchema = new Schema({
  cacheKey: { type: String, required: true, unique: true, index: true },
  response: { type: Schema.Types.Mixed, required: true },
  task: { type: String, required: true, index: true },
  createdAt: { type: Date, default: Date.now, index: true },
  expiresAt: { type: Date, required: true, index: true },
});

// TTL index for automatic cleanup
AICacheSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Get cached response
export async function getCachedAIResponse<T>(
  prompt: string,
  task: 'market-analysis' | 'feedback' | 'categorization' | 'other'
): Promise<T | null> {
  const cacheKey = crypto.createHash('sha256')
    .update(`${task}:${prompt}`)
    .digest('hex');
  
  // Check in-memory cache first
  const cached = memoryCache.get<T>(cacheKey);
  if (cached) return cached;
  
  // Check MongoDB
  await connectDB();
  const record = await AICacheModel.findOne({ cacheKey, expiresAt: { $gt: new Date() } });
  if (record) {
    // Store in memory cache for faster access
    const ttl = Math.ceil((record.expiresAt.getTime() - Date.now()) / 1000);
    memoryCache.set(cacheKey, record.response, ttl);
    return record.response as T;
  }
  
  return null;
}

// Cache AI response
export async function cacheAIResponse(
  prompt: string,
  response: any,
  task: 'market-analysis' | 'feedback' | 'categorization' | 'other',
  ttlSeconds: number = 86400
): Promise<void> {
  const cacheKey = crypto.createHash('sha256')
    .update(`${task}:${prompt}`)
    .digest('hex');
  
  const expiresAt = new Date(Date.now() + ttlSeconds * 1000);
  
  // Store in memory cache
  memoryCache.set(cacheKey, response, ttlSeconds);
  
  // Persist to MongoDB
  await connectDB();
  await AICacheModel.findOneAndUpdate(
    { cacheKey },
    {
      cacheKey,
      response,
      task,
      expiresAt,
    },
    { upsert: true }
  );
}
```

### Database Query Caching

**File: `lib/cache/queryCache.ts`**

Caches database query results to reduce database load.

#### Features:
- **5-minute default TTL** (configurable)
- **Model-based categorization**
- **Automatic expiration**
- **Cache invalidation** support

#### Implementation:

```typescript
// lib/cache/queryCache.ts
import NodeCache from 'node-cache';
import connectDB from '@/lib/mongodb';
import mongoose, { Schema } from 'mongoose';
import crypto from 'crypto';

const memoryCache = new NodeCache({
  stdTTL: 300, // 5 minutes
  checkperiod: 60, // Check every minute
});

const QueryCacheSchema = new Schema({
  cacheKey: { type: String, required: true, unique: true, index: true },
  result: { type: Schema.Types.Mixed, required: true },
  model: { type: String, required: true, index: true },
  createdAt: { type: Date, default: Date.now, index: true },
  expiresAt: { type: Date, required: true, index: true },
});

QueryCacheSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Get cached query result
export async function getCachedQuery<T>(
  query: any,
  model: string
): Promise<T | null> {
  const cacheKey = crypto.createHash('sha256')
    .update(`${model}:${JSON.stringify(query)}`)
    .digest('hex');
  
  const cached = memoryCache.get<T>(cacheKey);
  if (cached) return cached;
  
  await connectDB();
  const record = await QueryCacheModel.findOne({ 
    cacheKey, 
    expiresAt: { $gt: new Date() } 
  });
  
  if (record) {
    const ttl = Math.ceil((record.expiresAt.getTime() - Date.now()) / 1000);
    memoryCache.set(cacheKey, record.result, ttl);
    return record.result as T;
  }
  
  return null;
}

// Cache query result
export async function cacheQuery(
  query: any,
  result: any,
  model: string,
  ttlSeconds: number = 300
): Promise<void> {
  const cacheKey = crypto.createHash('sha256')
    .update(`${model}:${JSON.stringify(query)}`)
    .digest('hex');
  
  const expiresAt = new Date(Date.now() + ttlSeconds * 1000);
  
  memoryCache.set(cacheKey, result, ttlSeconds);
  
  await connectDB();
  await QueryCacheModel.findOneAndUpdate(
    { cacheKey },
    { cacheKey, result, model, expiresAt },
    { upsert: true }
  );
}
```

---

## Logging System

**File: `lib/logger.ts`**

Centralized logging utility with configurable log levels to reduce costs in production.

### Features:
- **Log Levels**: DEBUG, INFO, WARN, ERROR, NONE
- **Environment-based defaults**: ERROR in production, DEBUG in development
- **Configurable via `LOG_LEVEL` environment variable**
- **Structured error logging** with metadata
- **Cost optimization**: Filters logs in production

### Implementation:

```typescript
// lib/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4,
}

function getLogLevel(): LogLevel {
  const envLevel = process.env.LOG_LEVEL?.toUpperCase();
  
  if (envLevel === 'DEBUG') return LogLevel.DEBUG;
  if (envLevel === 'INFO') return LogLevel.INFO;
  if (envLevel === 'WARN') return LogLevel.WARN;
  if (envLevel === 'ERROR') return LogLevel.ERROR;
  if (envLevel === 'NONE') return LogLevel.NONE;
  
  // Default: ERROR in production, DEBUG in development
  return process.env.NODE_ENV === 'production' ? LogLevel.ERROR : LogLevel.DEBUG;
}

const currentLogLevel = getLogLevel();

export function debug(message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.DEBUG) {
    console.debug(`[DEBUG] ${message}`, ...args);
  }
}

export function info(message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.INFO) {
    console.info(`[INFO] ${message}`, ...args);
  }
}

export function warn(message: string, ...args: any[]): void {
  if (currentLogLevel <= LogLevel.WARN) {
    console.warn(`[WARN] ${message}`, ...args);
  }
}

export function error(message: string, error?: any, metadata?: Record<string, any>): void {
  if (currentLogLevel <= LogLevel.ERROR) {
    const errorDetails: any = {
      message,
      ...metadata,
    };
    
    if (error) {
      errorDetails.error = {
        message: error?.message,
        stack: process.env.NODE_ENV === 'development' ? error?.stack : undefined,
        code: error?.code,
        name: error?.name,
      };
    }
    
    console.error(`[ERROR] ${message}`, errorDetails);
  }
}

// Structured logging with context
export function log(
  context: string,
  level: LogLevel,
  message: string,
  data?: any
): void {
  if (currentLogLevel <= level) {
    const logData = {
      context,
      message,
      timestamp: new Date().toISOString(),
      ...(data && { data }),
    };
    
    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`[${context}]`, logData);
        break;
      case LogLevel.INFO:
        console.info(`[${context}]`, logData);
        break;
      case LogLevel.WARN:
        console.warn(`[${context}]`, logData);
        break;
      case LogLevel.ERROR:
        console.error(`[${context}]`, logData);
        break;
    }
  }
}
```

### Usage:

```typescript
import { debug, info, warn, error as logError } from '@/lib/logger';

// Debug (only in development)
debug('Processing request', { userId: '123' });

// Info (disabled in production by default)
info('User logged in', { userId: '123' });

// Warning (enabled in production)
warn('Rate limit approaching', { remaining: 5 });

// Error (always enabled)
logError('Failed to process request', error, { userId: '123' });
```

---

## API Route Handler Pattern

**File: `lib/api/routeHandler.ts`**

Centralized API route handler wrapper that provides:
- Rate limiting
- Authentication
- Database connection
- Error handling
- Response formatting

### Implementation:

```typescript
// lib/api/routeHandler.ts
import { NextRequest, NextResponse } from 'next/server';
import { requireAuth, requireAdmin, createAuthErrorResponse } from '@/lib/authMiddleware';
import { createRateLimitMiddleware, RateLimitConfig, RATE_LIMITS } from '@/lib/rateLimiter';
import { getSafeErrorMessage, logError } from '@/lib/errorHandler';
import connectDB from '@/lib/mongodb';

export interface HandlerContext {
  userId: string;
  isAdmin: boolean;
  email?: string;
  rateLimitRemaining: number;
  request: NextRequest;
}

export type RouteHandler = (
  request: NextRequest,
  context: HandlerContext
) => Promise<NextResponse | { [key: string]: any }>;

export interface RouteHandlerOptions {
  rateLimit?: RateLimitConfig;
  requireAuth?: boolean;
  requireAdmin?: boolean;
  handler: RouteHandler;
  errorContext?: string;
}

export function createApiHandler(options: RouteHandlerOptions) {
  const {
    rateLimit,
    requireAuth: needsAuth = false,
    requireAdmin: needsAdmin = false,
    handler,
    errorContext = 'API Handler',
  } = options;

  const rateLimiter = rateLimit ? createRateLimitMiddleware(rateLimit) : null;

  return async (request: NextRequest): Promise<NextResponse> => {
    try {
      // 1. Rate Limiting
      let rateLimitResult: { allowed: boolean; response?: NextResponse; remaining: number } | null = null;
      if (rateLimiter) {
        rateLimitResult = await rateLimiter(request);
        if (!rateLimitResult.allowed) {
          return rateLimitResult.response!;
        }
      }

      // 2. Authentication
      let auth: AuthResult | null = null;
      if (needsAdmin) {
        auth = await requireAdmin(request);
      } else if (needsAuth) {
        auth = await requireAuth(request);
      }

      if (auth && !auth.authenticated) {
        return createAuthErrorResponse(auth);
      }

      // 3. Database Connection
      if (!needsAuth && !needsAdmin) {
        await connectDB();
      }

      // 4. Create Handler Context
      const context: HandlerContext = {
        userId: auth?.userId || '',
        isAdmin: auth?.isAdmin || false,
        email: auth?.email,
        rateLimitRemaining: rateLimitResult?.remaining || 0,
        request,
      };

      // 5. Execute Handler
      const result = await handler(request, context);

      // 6. Format Response
      if (result instanceof NextResponse) {
        return result;
      }

      return NextResponse.json(result);
    } catch (error: any) {
      logError(`${errorContext} error:`, error, {
        method: request.method,
        url: request.url,
      });

      return NextResponse.json(
        { error: getSafeErrorMessage(error) },
        { status: error.statusCode || 500 }
      );
    }
  };
}
```

### Usage Example:

```typescript
// app/api/data/notes/route.ts
import { createApiHandler } from '@/lib/api/routeHandler';
import { RATE_LIMITS } from '@/lib/rateLimiter';
import ObjectionNote from '@/lib/models/ObjectionNote';
import { formatNote } from '@/lib/api/responseFormatters';

export const GET = createApiHandler({
  rateLimit: RATE_LIMITS.read,
  requireAuth: true,
  handler: async (req, { userId }) => {
    const notes = await ObjectionNote.find({ userId }).lean();
    return { notes: notes.map(formatNote) };
  },
});

export const POST = createApiHandler({
  rateLimit: RATE_LIMITS.api,
  requireAuth: true,
  handler: async (req, { userId }) => {
    const body = await req.json();
    const note = await ObjectionNote.create({
      ...body,
      userId,
    });
    return { note: formatNote(note) };
  },
});
```

---

## Database Setup

### MongoDB Connection

**File: `lib/mongodb.ts`**

```typescript
// lib/mongodb.ts
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI || '';

if (!MONGODB_URI) {
  throw new Error('Please define MONGODB_URI in environment variables');
}

interface MongooseCache {
  conn: typeof mongoose | null;
  promise: Promise<typeof mongoose> | null;
}

declare global {
  var mongoose: MongooseCache | undefined;
}

let cached: MongooseCache = global.mongoose || { conn: null, promise: null };

if (!global.mongoose) {
  global.mongoose = cached;
}

async function connectDB(): Promise<typeof mongoose> {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default connectDB;
```

### Mongoose Models

**File: `lib/models/User.ts` (example)**

```typescript
// lib/models/User.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
  username: string;
  email?: string;
  password: string;
  isAdmin: boolean;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const UserSchema = new Schema<IUser>(
  {
    username: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      minlength: 3,
      maxlength: 50,
    },
    email: {
      type: String,
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
    },
    isAdmin: {
      type: Boolean,
      default: false,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes
UserSchema.index({ username: 1 });
UserSchema.index({ email: 1 });
UserSchema.index({ isActive: 1 });

const User = mongoose.models.User || mongoose.model<IUser>('User', UserSchema);

export default User;
```

---

## Code Structure

### Directory Layout

```
app/
  api/              # API routes
    auth/           # Authentication endpoints
    data/           # Data CRUD endpoints
  page.tsx          # Main page
  layout.tsx         # Root layout
  globals.css       # Global styles

components/
  ui/               # shadcn/ui components
  *.tsx             # Feature components

lib/
  api/              # API utilities
    routeHandler.ts # Route handler wrapper
    responseFormatters.ts # Response formatters
  auth.ts           # Client-side auth
  authMiddleware.ts # Server-side auth middleware
  cache/            # Caching utilities
    aiCache.ts      # AI response caching
    queryCache.ts   # Query result caching
  jwt.ts            # JWT utilities
  logger.ts         # Logging utility
  mongodb.ts        # Database connection
  models/           # Mongoose models
  rateLimiter.ts    # Rate limiting
  utils.ts          # Utility functions (cn, etc.)

hooks/              # React hooks

docs/               # Documentation
```

### TypeScript Configuration

**File: `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### Next.js Configuration

**File: `next.config.ts`**

Key configurations:
- **Server-only packages**: Prevents bundling mongoose, mongodb, node-cache in client
- **Webpack aliases**: Excludes server-only lib files from client bundle
- **Security headers**: Applied to all routes
- **Request size limits**: Prevents DoS attacks

---

## Environment Variables

### Required Variables

```bash
# Database
MONGODB_URI=mongodb://localhost:27017/your-db-name

# JWT Authentication
JWT_SECRET=your-secret-key-minimum-32-characters
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Logging
LOG_LEVEL=ERROR  # DEBUG, INFO, WARN, ERROR, NONE
NODE_ENV=production

# Optional: External APIs
OPENAI_API_KEY=your-openai-key
ELEVENLABS_API_KEY=your-elevenlabs-key
```

### Environment-Specific Defaults

- **Development**: `LOG_LEVEL=DEBUG` (if not set)
- **Production**: `LOG_LEVEL=ERROR` (if not set)

---

## Best Practices

### 1. Always Use `createApiHandler`

Instead of writing raw Next.js API routes, use the wrapper:

```typescript
// ❌ Bad
export async function GET(request: NextRequest) {
  // Manual rate limiting, auth, error handling...
}

// ✅ Good
export const GET = createApiHandler({
  rateLimit: RATE_LIMITS.read,
  requireAuth: true,
  handler: async (req, { userId }) => {
    // Your logic here
  },
});
```

### 2. Use Centralized Logging

Replace all `console.log/error/warn` with logger functions:

```typescript
// ❌ Bad
console.error('Error:', error);
console.log('Debug info:', data);

// ✅ Good
import { error as logError, debug } from '@/lib/logger';
logError('Error processing request', error, { userId });
debug('Processing request', { userId });
```

### 3. Cache Expensive Operations

Use caching for:
- AI API responses
- Database queries that don't change frequently
- External API calls

```typescript
// Check cache first
const cached = await getCachedAIResponse(prompt, 'market-analysis');
if (cached) return cached;

// Fetch and cache
const response = await fetchAIResponse(prompt);
await cacheAIResponse(prompt, response, 'market-analysis');
return response;
```

### 4. Always Validate Input

Use centralized validation utilities:

```typescript
import { validatePassword, validateEmail } from '@/lib/validation';

const passwordError = validatePassword(password);
if (passwordError) {
  return NextResponse.json({ error: passwordError }, { status: 400 });
}
```

### 5. Use Response Formatters

Standardize API responses:

```typescript
import { formatUser, formatNote } from '@/lib/api/responseFormatters';

const user = await User.findById(userId).lean();
return { user: formatUser(user) };
```

### 6. Handle Errors Safely

Use `getSafeErrorMessage` to prevent information disclosure:

```typescript
import { getSafeErrorMessage, logError } from '@/lib/errorHandler';

try {
  // Your code
} catch (error) {
  logError('Operation failed', error, { context });
  return NextResponse.json(
    { error: getSafeErrorMessage(error) },
    { status: 500 }
  );
}
```

### 7. Type Safety

Always use TypeScript interfaces:

```typescript
export interface CreateNoteRequest {
  objectionId: string;
  content: string;
  userId: string;
}

export const POST = createApiHandler({
  handler: async (req, { userId }) => {
    const body: CreateNoteRequest = await req.json();
    // Type-safe body
  },
});
```

### 8. Database Indexes

Add indexes for frequently queried fields:

```typescript
UserSchema.index({ username: 1 });
UserSchema.index({ email: 1 });
UserSchema.index({ isActive: 1, createdAt: -1 }); // Compound index
```

### 9. Security Headers

Always include security headers in `next.config.ts` (already configured in this framework).

### 10. Environment-Based Behavior

Use environment variables for configuration:

```typescript
const isDevelopment = process.env.NODE_ENV === 'development';
const logLevel = process.env.LOG_LEVEL || (isDevelopment ? 'DEBUG' : 'ERROR');
```

---

## Quick Start Checklist

When building a new app with this framework:

1. ✅ Install dependencies (`package.json`)
2. ✅ Set up MongoDB connection (`lib/mongodb.ts`)
3. ✅ Configure environment variables
4. ✅ Set up JWT authentication (`lib/jwt.ts`, `lib/authMiddleware.ts`)
5. ✅ Implement rate limiting (`lib/rateLimiter.ts`)
6. ✅ Set up logging (`lib/logger.ts`)
7. ✅ Configure caching (`lib/cache/`)
8. ✅ Create API routes using `createApiHandler`
9. ✅ Add security headers (`next.config.ts`)
10. ✅ Set up TypeScript paths (`tsconfig.json`)
11. ✅ Configure Next.js for server-only modules (`next.config.ts`)

---

## Additional Resources

- [Next.js Documentation](https://nextjs.org/docs)
- [Mongoose Documentation](https://mongoosejs.com/docs)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)
- [OWASP Security Guidelines](https://owasp.org/www-project-top-ten/)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [shadcn/ui Components](https://ui.shadcn.com)

---

**Last Updated**: 2024-12-08
**Framework Version**: Next.js 16, React 19, TypeScript 5

